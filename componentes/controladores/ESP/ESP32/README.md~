## ESP32

- [Site contendo modelos e esquemáticos](http://esp32.net/)
- [URL do esquemático que baixei da ESPRESSIF](https://dl.espressif.com/dl/schematics/ESP32-Core-Board-V2_sch.pdf)
- [Cópia local do esquemático da ESPRESSIF](ESP32-Core-Board-V2_sch.pdf)
- [URL do esquemático que baixei do nodeMCU](http://esp32.net/images/Ai-Thinker/NodeMCU-32S/Ai-Thinker_NodeMCU-32S_DiagramSchematic.png)
- [Cópia local do esquemático do nodeMCU](Ai-Thinker_NodeMCU-32S_DiagramSchematic.png)
- [URL da foto com atribuição de pinos](https://pt.aliexpress.com/item/4000267191708.html?spm=a2g0o.productlist.0.0.81651027YPzmyr&algo_pvid=1a60ffda-ed96-4a60-be51-2452dc4a964b&algo_expid=1a60ffda-ed96-4a60-be51-2452dc4a964b-11&btsid=0ab50f4415991615959921606ea624&ws_ab_test=searchweb0_0,searchweb201602_,searchweb201603_)
- [Cópia local da foto com atribuição de pinos](Ha6b92f8013f544dca6078e05fc74a998r.jpg)
- [URL do esquemático do SparkFun Thing](https://cdn.sparkfun.com/assets/learn_tutorials/5/0/7/esp32-thing-schematic.pdf)
- [Cópia local do esquemático do SparkFun Thing](esp32-thing-schematic.pdf)

Mais modelos no projeto [ESP32-CAM](/projetos/ESP32-CAM/README.md)

## ESP32-C3

## 12F (AiThinker)

## 01Space

### ESP32-C3FH4-RGB

https://github.com/01Space/ESP32-C3FH4-RGB

Esta placa controladora contém uma matriz de LEDs RGB compatíveis com NeoPixel. Para testá-la portei o `Efeitos.py` do projeto [py-efeitos](/projetos/py-efeitos) 

1. Instalei Micropython [Referência neste repositório](https://github.com/FNakano/CFA/tree/master/programas/Micropython);
   - a placa é muito parecida com a placa com display, então tentei o mesmo firmware da placa com display;
   - captura de tela de 01space mostrando que é esse firmware mesmo: https://github.com/01Space/ESP32-C3-0.42LCD/blob/main/micropython/image/4.png
   - firmware sem conversor serial para usb: https://micropython.org/download/esp32c3-usb/
2. Configurei webREPL [Referência neste repositório](https://github.com/FNakano/CFA/tree/master/programas/Micropython/webREPL);
3. Ajustei o `boot.py` para reconectar ao meu WiFi e escrever no display qual é o IP;
   - enviei o `boot.py` para a placa através do webREPL;
      - o primeiro LED Neopixel está conectado à GPIO 8;
      - a matriz tem 25 LEDs;
   - para fins de arquivamento, renomeei `boot.py` para `bootRGB.py`;
3. Fiz esses ajustes em `Efeitos.py`;

### ESP32-C3-0.42LCD

https://github.com/01Space/ESP32-C3-0.42LCD

Esta placa controladora contém um display OLED com controlador SSD1306. Para testá-la:

1. Instalei Micropython [Referência neste repositório](https://github.com/FNakano/CFA/tree/master/programas/Micropython);
   - captura de tela de 01space mostrando que é esse firmware mesmo: https://github.com/01Space/ESP32-C3-0.42LCD/blob/main/micropython/image/4.png
   - firmware sem conversor serial para usb: https://micropython.org/download/esp32c3-usb/
2. Configurei webREPL [Referência neste repositório](https://github.com/FNakano/CFA/tree/master/programas/Micropython/webREPL);
3. Ajustei o `boot.py` para reconectar ao meu WiFi e escrever no display qual é o IP;
   - enviei o `boot.py` para a placa através do webREPL;
      - este boot cria a variável `oled`, que é a representação do display no programa;
   - para fins de arquivamento, renomeei `boot.py` para `bootOLED.py`;
3. Testei a biblioteca padrão para SSD1306 (https://docs.micropython.org/en/latest/esp8266/tutorial/ssd1306.html);
   - tem somente fonte 8 pixels monospace;
3. Usei um gerador de fontes (https://github.com/peterhinch/micropython-font-to-py), usei o `writer.py` desse mesmo projeto (https://github.com/peterhinch/micropython-font-to-py/blob/master/writer/WRITER.md) e adaptei o exemplo `writer_demo.py` (https://github.com/peterhinch/micropython-font-to-py/blob/master/writer/writer_demo.py) para usar com a biblioteca padrão.

O conversor de fonte é um programa em Python3 executado em desktop. Para instalá-lo, clonei o repositório https://github.com/peterhinch/micropython-font-to-py, instalei a dependência `freetype-py` e executei `./font_to_py.py -x ~/R/x86_64-pc-linux-gnu-library/3.6/rmarkdown/rmd/h/bootstrap/css/fonts/RobotoBold.ttf 28 roboto28.py`. Isto usa o fonte, codificado em `ttf` e cria um fonte bitmap codificado em Python. A opção `-x` é obrigatória. Sua falta causa o erro `ValueError: Font must be horizontally mapped`. Achar o tamanho certo foi por tentativa e erro.

Transferi para a placa, usando webREPL, os arquivos `writer.py` e `roboto28.py`. No console do webREPL, digitei o teste:

```python
from writer import Writer
import roboto28                                                                          
oled.fill(0) # limpa o display
wri=Writer(oled,roboto28) # instancia um Writer que envia letras para o oled
Writer.set_textpos(oled,0,0) # posiciona o cursor do framebuffer em 0,0
wri.printstring('22:22') # escreve a string no framebuffer
oled.show() # envia o conteúdo do framebuffer para o oled
```

